const express = require('express');
const { setTokenCookie, restoreUser, requireAuth } = require('../../utils/auth');
const { Booking, Spot } = require('../../db/models');
const router = express.Router();







//delete a booking
router.delete('/:bookingId', requireAuth, async (req, res) => {
    const id = req.params.id;
    const booking = Booking.findByPk(id);
})


//get bookings for current user
router.get('/current', requireAuth, async (req, res) => {
    const { user } = req;
    const all = await Booking.findAll({
        where: {
            userId: user.id
        }
    });
    return res.json(all);
});


// edit a booking
router.put('/:bookingId', requireAuth, async (req, res) => {
    const currbook = await Booking.findByPk(req.params.bookingId);
    if (!currbook) {
        res.status(404);
        res.body = { message: "Booking couldn't be found" };
        return res.json(res.body);
    };

    const bookObj = { startDate, endDate } = req.body;

    if (Object.keys(bookObj).length === 0) {
        res.status(400);
        res.body = {
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "startDate": "startDate cannot be in the past",
                "endDate": "endDate cannot be on or before startDate",
                "req.body": "req.body cannot be empty"
            }
        };
        return res.json(res.body);
    };



    for (const key in bookObj) {
        if (bookObj[key] === undefined || bookObj[key] === '') {
            res.status(400);
            res.body = {
                "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
                "errors": {
                    "startDate": "startDate cannot be in the past",
                    "endDate": "endDate cannot be on or before startDate"
                }
            };
            return res.json(res.body);
        };
    };

    const end = new Date(endDate);
    const start = new Date(startDate);

    if (end < Date.now()) {
        res.status(403);
        res.body = {
            message: "Past bookings can't be modified"
        };
        return res.json(res.body);
    };

    const alreadyBookedArr = Booking.findAll({
        where: {
            spotId: currbook.spotId
        }
    });

    alreadyBookedArr.forEach(booking => {
        const currStart = booking.startDate;
        const currEnd = booking.endDate;
        if (end <= currEnd && end >= currStart) {
            res.status(403);
            res.body = {
                "message": "Sorry, this spot is already booked for the specified dates",
                "errors": {
                    "startDate": "Start date conflicts with an existing booking",
                    "endDate": "End date conflicts with an existing booking"
                }
            };
            return res.json(res.body);
        };
        if (start <= currEnd && start >= currStart) {
            res.status(403);
            res.body = {
                "message": "Sorry, this spot is already booked for the specified dates",
                "errors": {
                    "startDate": "Start date conflicts with an existing booking",
                    "endDate": "End date conflicts with an existing booking"
                }
            };
            return res.json(res.body);
        };
    });


    await currbook.set({
        startDate: bookObj.startDate,
        endDate: bookObj.endDate
    });
    await currbook.save();
    res.body = currbook;
    res.json(res.body);
});

// get all bookings in booking table
router.get('/', requireAuth, async (req, res) => {
    const all = Booking.findAll();
    res.json(all);
});


module.exports = router
