const express = require('express');
const { setTokenCookie, restoreUser, requireAuth, authErrorCatcher } = require('../../utils/auth');
const { Booking, Spot } = require('../../db/models');
const router = express.Router();







//delete a booking
router.delete('/:bookingId', requireAuth, async (req, res) => {
    const booking = await Booking.findByPk(req.params.bookingId);
    const { user } = req;

    if (!booking) {
        res.status(404);
        return res.json({message: "Booking couldn't be found"});
    } else if(booking.userId !== user.id){
        res.status(403);
        return res.json({message:"Forbidden"});
    } else {
      await booking.destroy();
      res.status(200);
    return res.json({ message: "Successfully deleted" });
    }


});


//get bookings for current user
router.get('/current', requireAuth, async (req, res) => {
    const { user } = req;
    const all = await Booking.findAll({
        where: {
            userId: user.id
        }
    });
    return res.json(all);
});


// edit a booking
// router.put('/:bookingId', requireAuth, async (req, res) => {
//     const currbook = await Booking.findByPk(req.params.bookingId);
//     const { user } = req;


//     if (!currbook) {
//         res.status(404);
//         res.body = { message: "Booking couldn't be found" };
//         return res.json(res.body);
//     } else if (currbook.userId !== user.id) {
//         res.status(403);
//         return res.json({ message: "Forbidden" });
//     } else {
//         const bookObj = { startDate, endDate } = req.body;
//         const end = new Date(endDate);
//         const start = new Date(startDate);
//         const currDate = new Date();
//         const alreadyBookedArr = await Booking.findAll({
//             where: {
//                 spotId: currbook.spotId
//             }
//         });

//         if (Object.keys(bookObj).length === 0) {
//             res.status(400);
//             res.body = {
//                 "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
//                 "errors": {
//                     "req.body": "req.body cannot be empty"
//                 }
//             };
//             return res.json(res.body);
//         };

//         for (const key in bookObj) {
//             if (bookObj[key] === undefined || bookObj[key] === '') {
//                 res.status(400);
//                 res.body = {
//                     "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
//                     "errors": {
//                         "startDate": "startDate cannot be in the past",
//                         "endDate": "endDate cannot be on or before startDate"
//                     }
//                 };
//                 return res.json(res.body);
//             };
//         };


//         if (end < currDate) {
//             res.status(403);
//             res.body = {
//                 message: "Past bookings can't be modified"
//             };
//             return res.json(res.body);
//         };

//         alreadyBookedArr.forEach(booking => {
//             const currStart = booking.startDate;
//             const currEnd = booking.endDate;
//             // end start currdate

//             if(start >= end){
//                 res.status(400);
//                 return res.json({
//                     "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
//                     "errors": {
//                     "endDate": "endDate cannot be on or before startDate"
//                 }});
//             };
//             if (end <= currEnd && end >= currStart) {
//                 res.status(403);
//                 res.body = {
//                     "message": "Sorry, this spot is already booked for the specified dates",
//                     "errors": {
//                         "startDate": "Start date conflicts with an existing booking",
//                         "endDate": "End date conflicts with an existing booking"
//                     }
//                 };
//                 return res.json(res.body);
//             };
//             if (start <= currEnd && start >= currStart) {
//                 res.status(403);
//                 res.body = {
//                     "message": "Sorry, this spot is already booked for the specified dates",
//                     "errors": {
//                         "startDate": "Start date conflicts with an existing booking",
//                         "endDate": "End date conflicts with an existing booking"
//                     }
//                 };
//                 return res.json(res.body);
//             };
//             if(currStart <= start && currEnd >= end){
//                 res.status(403);
//                 res.json({
//                     "message": "Sorry, this spot is already booked for the specified dates",
//                     "errors": {
//                         "startDate": "Start date conflicts with an existing booking",
//                         "endDate": "End date conflicts with an existing booking"
//                     }
//                 })
//             };
//         });

//         await currbook.set({
//             startDate: bookObj.startDate,
//             endDate: bookObj.endDate
//         });
//         await currbook.save();
//         res.body = currbook;
//         res.status(200);
//         return res.json(currbook);
//     };
// });
//=====================================================================================================
router.put("/:bookingId", requireAuth, async (req, res) => {
    let currentUser = req.user;
    let bookingId = req.params.bookingId;

    let existingBooking = await Booking.findByPk(bookingId);
    if (!existingBooking) {
      res.status(404);
      return res.json({ "message": "Booking could not be found " });

    } else if (currentUser.id !== existingBooking.userId) {
      res.status(403);
      return res.json({ "message": "Forbidden" });

    } else {
      existingBooking = await Booking.findOne({
        where: {
          id: bookingId,
          userId: currentUser.id
        }
      });

      let allBookings = await Booking.findAll({
        where: { spotId: existingBooking.spotId }
      });

      let { startDate, endDate } = req.body;
      let currentDate = new Date();
      let errors = {};

      for (let booking of allBookings) {
        if (booking.id !== existingBooking.id) {
          if (new Date(booking.startDate) > new Date(startDate) &&
            new Date(booking.endDate) < new Date(endDate)) {
            errors.conflicts = "Start date and end date conflict with an existing booking";
          }

          if (new Date(booking.startDate) <= new Date(startDate) &&
            new Date(booking.endDate) >= new Date(endDate)) {
            errors.conflicts = "Start date and end date conflict with an existing booking";
          }

          if (new Date(startDate) >= new Date(booking.startDate) &&
            new Date(startDate) <= new Date(booking.endDate)) {
            errors.startDate = "Start date conflicts with an existing booking";

          } if (new Date(endDate) >= new Date(booking.startDate) &&
            new Date(endDate) <= new Date(booking.endDate)) {
            errors.endDate = "End date conflicts with an existing booking";
          }
        }
      }

      if (Object.keys(errors).length > 0) {
        res.status(403);
        return res.json({
          "message": "Sorry, this spot is already booked for the specified dates",
          errors
        });
      }

      if (new Date(startDate) >= new Date(endDate)) {
        res.status(400);
        return res.json({ "message": "endDate cannot be on or before startDate" })
      }

      if (new Date(existingBooking.endDate) <= currentDate) {
        res.status(403);
        return res.json({ "message": "Past bookings can't be modified" });
      }


      if (new Date(startDate) <= currentDate || new Date(endDate) <= currentDate) {
        res.status(403);
        return res.json({ "message": "Cannot book past dates" });
      }

      existingBooking.startDate = startDate;
      existingBooking.endDate = endDate;

      await existingBooking.save();
      res.status(200);
      return res.json(existingBooking);
    }
  });

// get all bookings in booking table
router.get('/', requireAuth, async (req, res) => {
    const all = Booking.findAll();
    res.json(all);
});


router.use(authErrorCatcher);
module.exports = router
