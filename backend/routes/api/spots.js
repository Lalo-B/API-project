const express = require('express');
const { Sequelize } = require('sequelize');
const { setTokenCookie, restoreUser, requireAuth, authErrorCatcher } = require('../../utils/auth');
const { Spot, SpotImage, User, Booking, Review } = require('../../db/models');
const router = express.Router();




//Create a Booking from a Spot based on the Spot's id
router.post('/:spotId/bookings', requireAuth, async (req, res) => {
    let currSpot
    if (req.params.spotId) {
        currSpot = await Spot.findByPk(req.params.spotId);
        if (!currSpot) {
            res.status(404);
            res.body = { message: "Spot couldn't be found" };
            return res.json(res.body);
        };
    };

    const { user } = req;
    const { startDate, endDate } = req.body;
    const spotBookings = await Booking.findAll({
        where: {
            spotId: currSpot.id
        }
    });


    if (spotBookings) {
        spotBookings.forEach((booking) => {
            let start = booking.startDate;
            let end = booking.endDate;
            let actStart = new Date(startDate);
            let actEnd = new Date(endDate);
            if (actEnd < Date.now() || actStart < Date.now()) {
                res.status(400);
                res.body = {
                    "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
                    "errors": {
                        "startDate": "startDate cannot be in the past",
                        "endDate": "endDate cannot be on or before startDate"
                    }
                };
                return res.json(res.body);
            };
            if (actStart <= end && actStart >= start) {
                res.status(403);
                res.body = {
                    "message": "Sorry, this spot is already booked for the specified dates",
                    "errors": {
                        "startDate": "Start date conflicts with an existing booking",
                        "endDate": "End date conflicts with an existing booking"
                    }
                };
                return res.json(res.body);
            };
            if (actEnd <= end && actEnd >= start) {
                res.status(403);
                res.body = {
                    "message": "Sorry, this spot is already booked for the specified dates",
                    "errors": {
                        "startDate": "Start date conflicts with an existing booking",
                        "endDate": "End date conflicts with an existing booking"
                    }
                };
                return res.json(res.body);
            };
        });
    };


    if (startDate && endDate) {
        const newBooking = await Booking.create({
            spotId: +req.params.spotId,
            userId: user.id,
            startDate, endDate
        });
        res.body = newBooking;
        return res.json(res.body);
    } else {
        res.status(400);
        res.body = {
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "startDate": "startDate cannot be in the past",
                "endDate": "endDate cannot be on or before startDate"
            }
        };
        return res.json(res.body)
    };
});


//Get all Spots owned by the Current User
router.get('/current', requireAuth, async (req, res) => {
    const { user } = req;
    const spots = await Spot.findAll({
        where: {
            ownerId: user.id
        },
    });
    return res.json(spots);
});

//Create a Review for a Spot based on the Spot's id
router.post('/:spotId/reviews', requireAuth, async (req, res) => {
    const { spotId, userId, review, stars } = req.body;
    const { user } = req;
    const foundSpot = await Spot.findByPk(req.params.spotId);
    if (foundSpot === null) {
        res.status(404);
        res.body = { message: "Spot couldn't be found" }
        return res.json(res.body);
    };

    const alreadyReview = Review.findAll({
        where: {
            spotId: req.params.spotId,
            userId: user.id
        }
    })
    if (alreadyReview) {
        res.status(500);
        res.body = { message: "User already has a review for this spot" };
        return res.json(res.body);
    };

    if (spotId && userId && review && stars) {
        const newR = await Review.create({
            spotId, userId, review, stars
        });
    } else {
        res.status(400);
        res.body = {
            "message": "Bad Request",
            "errors": {
                "review": "Review text is required",
                "stars": "Stars must be an integer from 1 to 5",
            }
        }
        return res.json(res.body);
    };
    res.status(201);
    res.body = {
        review, stars
    };
    return res.json(res.body);
});


//Get all Bookings for a Spot based on the Spot's id
router.get('/:spotId/bookings', requireAuth, async (req, res) => {
    const { user } = req;
    const spot = await Spot.findAll({
        where: {
            id: req.params.spotId
        },
        include: [{
            model: Booking,
            through: Booking.id
        }, {
            model: User,
            through: User.id
        }]
    });

    if (spot.length === 0) {
        res.status(404)
        return res.json({ message: 'Spot couldn\'t be found' })
    };

    Bookings = [];
    if (user.id === spot[0].ownerId) {
        spot.forEach(booking => {
            let actualB = booking.Bookings;
            let actualU = booking.User;
            const { id, spotId, userId, startDate, endDate, createdAt, updatedAt } = actualB[0];
            Bookings.push({
                User: { actualU },
                id, spotId, userId, startDate, endDate, createdAt, updatedAt
            });
        });
    } else {
        spot.forEach(booking => {
            const { spotId, startDate, endDate } = booking.Bookings[0];
            // console.log(booking.Bookings)
            Bookings.push({ spotId, startDate, endDate });
        });
    };
    res.body = { Bookings };

    return res.json(res.body);
});

// add an image to a spot based on the spots id
router.post('/:spotId/images', requireAuth, async (req, res) => {
    const spot = await Spot.findByPk(req.params.id);
    if (spot === null) {
        res.status(404);
        res.body = { message: "Spot couldn't be found" }
        return res.json(res.body)
    };
    const newImg = req.body.url;
    const img = await SpotImage.create({
        spotId: req.params.spotId,
        url: newImg,
        preview: true
    });

    res.body = {
        id: img.id,
        url: img.url,
        preview: img.preview
    };
    return res.json(res.body);
});


// get details for a spot from an id
router.get('/:spotId', requireAuth, async (req, res) => {
    console.log(req.query.spotId);
    const spotInfo = await Spot.findAll({
        where: {
            id: req.query.spotId
        },
        include: [{
            model: SpotImage,
            through: Spot.id,
            attributes: ['id', 'url', 'preview']
        },
        {
            model: User,
            through: User.id,
            // as: 'Owner',
            attributes: ['id', 'firstName', 'lastName']
        }]
    })
    if (!spotInfo) {
        res.status(404);
        return res.json({
            message: "Spot couldn't be found"
        })
    };
    res.body = {
        spotInfo,
        SpotImages: SpotImage,
        Owner: User,
    }
    return res.json(res.body);
});


// create new spot
router.post('/', requireAuth, async (req, res) => {
    let spotObj = {
        ownerId,
        address,
        city,
        state,
        country,
        lat,
        lng,
        name,
        description,
        price
    } = req.body;

    if (Object.keys(spotObj).length === 0) {
        res.status(400);
        res.body = {
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "address": "Street address is required",
                "city": "City is required",
                "state": "State is required",
                "country": "Country is required",
                "lat": "Latitude must be within -90 and 90",
                "lng": "Longitude must be within -180 and 180",
                "name": "Name must be less than 50 characters",
                "description": "Description is required",
                "price": "Price per day must be a positive number"
            }
        };
        return res.json(res.body);
    }
    let newSpot = await Spot.create({
        ownerId: spotObj.ownerId,
        address: spotObj.address,
        city: spotObj.city,
        state: spotObj.state,
        country: spotObj.country,
        lat: spotObj.lat,
        lng: spotObj.lng,
        name: spotObj.name,
        description: spotObj.description,
        price: '$' + spotObj.price
    });

    res.status(201);
    return res.json(newSpot);
});

//delete spot by id
router.delete('/:spotId', requireAuth, async (req, res) => {
    const thisOne = await Spot.findByPk(req.params.spotId);
    if (!thisOne) {
        res.status(404);
        res.body = { message: 'Spot couldn\'t be found' };
        return res.json(res.body);
    };
    await thisOne.destroy();
    res.body = { message: "successfully deleted" }
    return res.json(res.body);
});

// update a spot
router.put('/:spotId', requireAuth, async (req, res) => {
    let spot;
    if (req.params.spotId) {
        spot = await Spot.findByPk(req.params.spotId);
    };
    if (!spot) {
        res.status(404);
        res.body = { message: "Spot couldn't be found" };
        return res.json(res.body);
    };


    const updateObj = {
        address, city, state, country, lat,
        lng, name, description, price
    } = req.body;

    if (Object.keys(updateObj).length === 0) {
        res.status(400);
        res.body = {
            "message": "Bad Request",
            "errors": {
                "address": "Street address is required",
                "city": "City is required",
                "state": "State is required",
                "country": "Country is required",
                "lat": "Latitude must be within -90 and 90",
                "lng": "Longitude must be within -180 and 180",
                "name": "Name must be less than 50 characters",
                "description": "Description is required",
                "price": "Price per day must be a positive number"
            }
        };
        return res.json(res.body);
    };

    for (let key in updateObj) {
        if (!updateObj[key]) {
            res.status(400);
            res.body = {
                "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
                "errors": {
                    "address": "Street address is required",
                    "city": "City is required",
                    "state": "State is required",
                    "country": "Country is required",
                    "lat": "Latitude must be within -90 and 90",
                    "lng": "Longitude must be within -180 and 180",
                    "name": "Name must be less than 50 characters",
                    "description": "Description is required",
                    "price": "Price per day must be a positive number"
                }
            };
            return res.json(res.body);
        }
    };


    await spot.set({
        address: updateObj.address,
        city: updateObj.city,
        state: updateObj.state,
        country: updateObj.country,
        lat: updateObj.lat,
        lng: updateObj.lng,
        name: updateObj.name,
        description: updateObj.description,
        price: `$${updateObj.price}`
    });
    await spot.save();
    res.body = updateObj;
    return res.json(res.body);
});




// find all spots with query parameters
router.get('/', requireAuth, async (req, res) => {
    let obj = { page, size, minLat, maxLat, minLng, maxLng, minPrice, maxPrice } = req.query;

    if (isNaN(obj.page) || obj.page <= 0) obj.page = 1;
    if (isNaN(obj.size) || obj.size <= 0) obj.size = 20;
    if (size > 20) size = 20;

    const where = {};
    if (Object, keys(obj).length === 0) {
        res.status(400);
        res.body = {
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "page": "Page must be greater than or equal to 1",
                "size": "Size must be greater than or equal to 1",
                "maxLat": "Maximum latitude is invalid",
                "minLat": "Minimum latitude is invalid",
                "minLng": "Maximum longitude is invalid",
                "maxLng": "Minimum longitude is invalid",
                "minPrice": "Minimum price must be greater than or equal to 0",
                "maxPrice": "Maximum price must be greater than or equal to 0"
            }
        };
        return res.json(res.body);
    };
    for (const key in obj) {
        if (obj[key] === undeinfed || obj[key] === '') {
            res.status(400);
            res.body = {
                "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
                "errors": {
                    "page": "Page must be greater than or equal to 1",
                    "size": "Size must be greater than or equal to 1",
                    "maxLat": "Maximum latitude is invalid",
                    "minLat": "Minimum latitude is invalid",
                    "minLng": "Maximum longitude is invalid",
                    "maxLng": "Minimum longitude is invalid",
                    "minPrice": "Minimum price must be greater than or equal to 0",
                    "maxPrice": "Maximum price must be greater than or equal to 0"
                }
            };
            return res.json(res.body);
        }
    };





    const spots = await Spot.findAll({
        where,
        limit: size,
        offset: (page - 1) * size
    });
    return res.json({
        spots,
        page: +page,
        size: +size
    });
});

router.use(authErrorCatcher);

module.exports = router;
